# Closures in JS

## Definition

A closure is created when a function remembers and can access variables from its outer scope, even after the outer function has finished executing.

In other words:
**A closure = function + its lexical environment.**

## How Closures Work

- Every function in JavaScript forms a lexical environment at creation.
- When an inner function is returned or passed around, it still carries a reference to the variables in its outer scope.
- This is possible because JavaScript uses lexical scoping â€” scope is determined by where the function is physically written in the code, not where it's called.

## Example

```javascript
function outer() {
  let counter = 0;

  function inner() {
    counter++;
    console.log(counter);
  }

  return inner;
}

const increment = outer();
increment(); // 1
increment(); // 2
increment(); // 3
```

**What happens here:**

- `outer()` finishes execution, but `counter` is not garbage-collected because `inner` still references it.
- `increment` is now a closure that keeps `counter` alive.

## Common Uses of Closures

### 1. Data privacy / encapsulation

```javascript
function secret() {
  let password = '12345';
  return {
    getPass: function () {
      return password;
    },
  };
}
const obj = secret();
console.log(obj.getPass()); // 12345
```

### 2. Function factories

```javascript
function multiplier(x) {
  return function (y) {
    return x * y;
  };
}
const double = multiplier(2);
console.log(double(5)); // 10
```

### 3. Maintaining state between calls (as in the counter example)

### 4. setTimeout / async callbacks

```javascript
function delayedMessage(msg) {
  setTimeout(function () {
    console.log(msg);
  }, 1000);
}
delayedMessage('Hello Closure!');
```

## Memory Behavior

- Variables used in a closure stay in memory as long as the closure exists.
- This can be powerful but also lead to memory leaks if not managed properly.

## Interview Soundbite

"A closure is formed when a function retains access to variables from its lexical scope, even after the outer function has returned. This is possible because JavaScript uses lexical scoping, so functions remember the environment in which they were created. Closures are used for data privacy, state maintenance, and function factories."
