# Creating a Promise, Chaining and Error Handling

## Creating a Promise

A Promise is created with the Promise constructor, which takes an executor function.
The executor gets two functions:

- **resolve(value)** â†’ marks promise as fulfilled
- **reject(reason)** â†’ marks promise as rejected

**Example:**

```js
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve('Data loaded successfully');
    } else {
      reject('Error loading data');
    }
  }, 1000);
});
```

## Consuming a Promise

A promise is used with:

- **.then()** â†’ when fulfilled
- **.catch()** â†’ when rejected
- **.finally()** â†’ runs regardless of result

```js
fetchData
  .then((result) => console.log(result))
  .catch((error) => console.error(error))
  .finally(() => console.log('Request complete'));
```

## Chaining Promises

Each `.then()` returns a new Promise, allowing you to chain async operations in sequence.

**Example:**

```js
getUser(1)
  .then((user) => getPosts(user.id)) // returns promise
  .then((posts) => getComments(posts[0].id))
  .then((comments) => console.log(comments))
  .catch((err) => console.error(err));
```

**Flow:**

1. `getUser` resolves â†’ passes user to next `.then()`
2. `getPosts` resolves â†’ passes posts to next `.then()`
3. `getComments` resolves â†’ final `.then()` logs data

ðŸ’¡ This avoids callback hell by flattening the structure.

## Error Handling in Promises

### Single .catch() for the whole chain

If any promise in the chain rejects, control jumps to the nearest `.catch()`.

```js
getUser(1)
  .then((user) => getPosts(user.id))
  .then((posts) => {
    throw new Error('Failed to load posts');
  })
  .then((posts) => getComments(posts[0].id))
  .catch((err) => console.error('Error:', err.message));
```

Even the thrown error inside `.then()` goes to `.catch()`.

### Multiple catches

You can handle errors at different points, but best practice is usually one final `.catch()` unless specific cases need separate handling.

### Finally block

Runs regardless of success/failure â€” useful for cleanup.

```js
fetchData
  .then((data) => console.log(data))
  .catch((err) => console.error(err))
  .finally(() => console.log('Finished operation'));
```

## Interview-Ready Summary

To create a Promise, you use the `new Promise` constructor with an executor that calls `resolve` on success or `reject` on failure. Chaining works because each `.then()` returns a new Promise, passing results down the chain, which keeps async code flat and readable. Errors are handled with `.catch()`, which catches both rejections and exceptions thrown inside `.then()`. `.finally()` runs after completion regardless of the outcome.
